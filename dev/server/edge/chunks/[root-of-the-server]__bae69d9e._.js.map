{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/supabase/server/server.ts"],"sourcesContent":["import { cookies } from \"next/headers\";\n\nimport { createServerClient } from \"@supabase/ssr\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\n\nexport async function createClient() {\n  const cookieStore = await cookies();\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll();\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              cookieStore.set(name, value, options);\n            });\n          } catch {\n            // No-op\n          }\n        },\n      },\n    }\n  );\n}\n\nexport function createAdminClient() {\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      global: {\n        headers: {\n          \"x-service-role\": \"true\",\n        },\n      },\n      cookies: {\n        getAll() {\n          return [];\n        },\n        setAll() {\n          // No-op\n        },\n      },\n    }\n  );\n}\n\nexport async function createClientFromJwt(jwt: string) {\n  if (!jwt) {\n    console.error(\"No JWT provided\");\n    return;\n  }\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      global: {\n        headers: {\n          Authorization: `Bearer ${jwt}`,\n        },\n      },\n      cookies: {\n        getAll() {\n          return [];\n        },\n        setAll() {\n          // No-op\n        },\n      },\n    }\n  );\n}\n\nexport async function getUser(supabase: SupabaseClient) {\n  const {\n    data: { user },\n    error: error,\n  } = await supabase.auth.getUser();\n\n  if (error) {\n    console.error(\"Error getting user:\", error.message);\n    return null;\n  }\n\n  return user;\n}\n\nexport async function getUserId(supabase: SupabaseClient) {\n  const user = await getUser(supabase);\n\n  if (!user) {\n    console.error(\"No session found\");\n    return null;\n  }\n\n  return user.id || null;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAAA;AAEA;AAAA;;;AAGO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,sLAAO;IAEjC,OAAO,IAAA,uMAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;wBAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAC/B;gBACF,EAAE,OAAM;gBACN,QAAQ;gBACV;YACF;QACF;IACF;AAEJ;AAEO,SAAS;IACd,OAAO,IAAA,uMAAkB,gFAEvB,QAAQ,GAAG,CAAC,yBAAyB,EACrC;QACE,QAAQ;YACN,SAAS;gBACP,kBAAkB;YACpB;QACF;QACA,SAAS;YACP;gBACE,OAAO,EAAE;YACX;YACA;YACE,QAAQ;YACV;QACF;IACF;AAEJ;AAEO,eAAe,oBAAoB,GAAW;IACnD,IAAI,CAAC,KAAK;QACR,QAAQ,KAAK,CAAC;QACd;IACF;IAEA,OAAO,IAAA,uMAAkB,sUAGvB;QACE,QAAQ;YACN,SAAS;gBACP,eAAe,CAAC,OAAO,EAAE,KAAK;YAChC;QACF;QACA,SAAS;YACP;gBACE,OAAO,EAAE;YACX;YACA;YACE,QAAQ;YACV;QACF;IACF;AAEJ;AAEO,eAAe,QAAQ,QAAwB;IACpD,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,OAAO,KAAK,EACb,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,OAAO;QACT,QAAQ,KAAK,CAAC,uBAAuB,MAAM,OAAO;QAClD,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAe,UAAU,QAAwB;IACtD,MAAM,OAAO,MAAM,QAAQ;IAE3B,IAAI,CAAC,MAAM;QACT,QAAQ,KAAK,CAAC;QACd,OAAO;IACT;IAEA,OAAO,KAAK,EAAE,IAAI;AACpB"}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/supabase/server/auth.ts"],"sourcesContent":["import { SupabaseClient } from \"@supabase/supabase-js\";\n\nimport { getUserId } from \"./server\";\n\nexport async function checkAuth(supabase: SupabaseClient): Promise<boolean> {\n  console.log(\"Checking auth...\");\n\n  const {\n    data: { session },\n    error,\n  } = await supabase.auth.getSession();\n\n  if (error) {\n    console.error(\"Error checking auth:\", error.message);\n    return false;\n  }\n\n  console.log(\"Session state:\", {\n    hasSession: !!session,\n    sessionExpiresAt: session?.expires_at,\n    sessionUser: session?.user?.email,\n  });\n\n  return !!session;\n}\n\nexport async function checkRole(\n  supabase: SupabaseClient,\n  roles: string[]\n): Promise<boolean> {\n  const userId = await getUserId(supabase);\n  if (!userId) {\n    return false;\n  }\n\n  const { data, error } = await supabase\n    .from(\"user_roles\")\n    .select(\"roles(name)\")\n    .eq(\"user_id\", userId);\n\n  if (error) {\n    console.error(\"Error checking role:\", error.message);\n    return false;\n  }\n\n  if (!data || data.length === 0) {\n    console.error(\"No roles found for user\");\n    return false;\n  }\n\n  const userRoles = data.flatMap((entry) => {\n    if (Array.isArray(entry.roles)) {\n      return entry.roles.map((role) => role.name);\n    } else if (entry.roles && typeof entry.roles === \"object\") {\n      return [(entry.roles as { name: string }).name];\n    }\n    return [];\n  });\n\n  console.log(\"User roles fetched:\", userRoles);\n\n  const hasExactRole = roles.some((requiredRole) =>\n    userRoles.includes(requiredRole)\n  );\n\n  if (hasExactRole) {\n    console.log(\"User has the exact required role:\", roles);\n    return true;\n  } else {\n    console.error(\"User does not have any of the required roles:\", roles);\n    return false;\n  }\n}\n\nexport async function checkAllRoles(\n  supabase: SupabaseClient,\n  roles: string[]\n): Promise<boolean> {\n  type UserRoleEntry = {\n    roles: { name: string } | { name: string }[];\n  };\n\n  const userId = await getUserId(supabase);\n  if (!userId) {\n    console.error(\"User is not logged in\");\n    return false;\n  }\n\n  const { data, error } = await supabase\n    .from(\"user_roles\")\n    .select(\"roles(name)\")\n    .eq(\"user_id\", userId);\n\n  if (error) {\n    console.error(\"Error checking roles:\", error.message);\n    return false;\n  }\n\n  if (!data || data.length === 0) {\n    console.error(\"No roles found for user\");\n    return false;\n  }\n\n  const userRoles = data.flatMap((entry: UserRoleEntry) => {\n    const rolesField = entry.roles;\n    if (Array.isArray(rolesField)) {\n      return rolesField.map((role) => role.name);\n    } else if (\n      rolesField &&\n      typeof rolesField === \"object\" &&\n      \"name\" in rolesField\n    ) {\n      return [rolesField.name];\n    }\n    return [];\n  });\n  console.log(\"User roles:\", userRoles);\n\n  const hasAllRoles = roles.every((requiredRole) =>\n    userRoles.includes(requiredRole)\n  );\n\n  if (hasAllRoles) {\n    console.log(\"User has all the required roles\");\n    return true;\n  } else {\n    console.error(\"User does not have all the required roles\");\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;;AAEO,eAAe,UAAU,QAAwB;IACtD,QAAQ,GAAG,CAAC;IAEZ,MAAM,EACJ,MAAM,EAAE,OAAO,EAAE,EACjB,KAAK,EACN,GAAG,MAAM,SAAS,IAAI,CAAC,UAAU;IAElC,IAAI,OAAO;QACT,QAAQ,KAAK,CAAC,wBAAwB,MAAM,OAAO;QACnD,OAAO;IACT;IAEA,QAAQ,GAAG,CAAC,kBAAkB;QAC5B,YAAY,CAAC,CAAC;QACd,kBAAkB,SAAS;QAC3B,aAAa,SAAS,MAAM;IAC9B;IAEA,OAAO,CAAC,CAAC;AACX;AAEO,eAAe,UACpB,QAAwB,EACxB,KAAe;IAEf,MAAM,SAAS,MAAM,IAAA,wJAAS,EAAC;IAC/B,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,cACL,MAAM,CAAC,eACP,EAAE,CAAC,WAAW;IAEjB,IAAI,OAAO;QACT,QAAQ,KAAK,CAAC,wBAAwB,MAAM,OAAO;QACnD,OAAO;IACT;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;QAC9B,QAAQ,KAAK,CAAC;QACd,OAAO;IACT;IAEA,MAAM,YAAY,KAAK,OAAO,CAAC,CAAC;QAC9B,IAAI,MAAM,OAAO,CAAC,MAAM,KAAK,GAAG;YAC9B,OAAO,MAAM,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;QAC5C,OAAO,IAAI,MAAM,KAAK,IAAI,OAAO,MAAM,KAAK,KAAK,UAAU;YACzD,OAAO;gBAAE,MAAM,KAAK,CAAsB,IAAI;aAAC;QACjD;QACA,OAAO,EAAE;IACX;IAEA,QAAQ,GAAG,CAAC,uBAAuB;IAEnC,MAAM,eAAe,MAAM,IAAI,CAAC,CAAC,eAC/B,UAAU,QAAQ,CAAC;IAGrB,IAAI,cAAc;QAChB,QAAQ,GAAG,CAAC,qCAAqC;QACjD,OAAO;IACT,OAAO;QACL,QAAQ,KAAK,CAAC,iDAAiD;QAC/D,OAAO;IACT;AACF;AAEO,eAAe,cACpB,QAAwB,EACxB,KAAe;IAMf,MAAM,SAAS,MAAM,IAAA,wJAAS,EAAC;IAC/B,IAAI,CAAC,QAAQ;QACX,QAAQ,KAAK,CAAC;QACd,OAAO;IACT;IAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,cACL,MAAM,CAAC,eACP,EAAE,CAAC,WAAW;IAEjB,IAAI,OAAO;QACT,QAAQ,KAAK,CAAC,yBAAyB,MAAM,OAAO;QACpD,OAAO;IACT;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;QAC9B,QAAQ,KAAK,CAAC;QACd,OAAO;IACT;IAEA,MAAM,YAAY,KAAK,OAAO,CAAC,CAAC;QAC9B,MAAM,aAAa,MAAM,KAAK;QAC9B,IAAI,MAAM,OAAO,CAAC,aAAa;YAC7B,OAAO,WAAW,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;QAC3C,OAAO,IACL,cACA,OAAO,eAAe,YACtB,UAAU,YACV;YACA,OAAO;gBAAC,WAAW,IAAI;aAAC;QAC1B;QACA,OAAO,EAAE;IACX;IACA,QAAQ,GAAG,CAAC,eAAe;IAE3B,MAAM,cAAc,MAAM,KAAK,CAAC,CAAC,eAC/B,UAAU,QAAQ,CAAC;IAGrB,IAAI,aAAa;QACf,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT,OAAO;QACL,QAAQ,KAAK,CAAC;QACd,OAAO;IACT;AACF"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/supabase/server/middleware.ts"],"sourcesContent":["import { NextResponse, type NextRequest } from \"next/server\";\n\nimport { createServerClient } from \"@supabase/ssr\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\n\nimport { checkAllRoles, checkAuth, checkRole } from \"./auth\";\n\n/**\n * Protects a path by checking if the user is authenticated and has the required\n * roles. If the user is not authenticated or does not have the required roles,\n * they are redirected to the unauthorized path.\n *\n * @param supabase - The Supabase client.\n * @param roles - The roles required to access the path.\n * @param allRequired - Whether all roles are required.\n * @param unauthorizedPath - The path to redirect to if the user is not\n *                           authorized.\n *\n * @returns The path to redirect to if the user is not authorized, or null if\n *          the user is authorized.\n */\nasync function protectPath(\n  supabase: SupabaseClient,\n  roles: string[] | null,\n  allRequired: boolean = false,\n  unauthorizedPath: string = \"/unauthorized\"\n) {\n  let authorized = false;\n\n  const isAuthenticated = await checkAuth(supabase);\n  if (!isAuthenticated) {\n    return unauthorizedPath;\n  }\n\n  if (!roles || roles.length === 0) {\n    return null;\n  }\n\n  if (allRequired) {\n    authorized = await checkAllRoles(supabase, roles);\n  } else {\n    authorized = await checkRole(supabase, roles);\n  }\n\n  if (!authorized) {\n    return unauthorizedPath;\n  }\n\n  return null;\n}\n\nconst protectedRoutes = [\n  {\n    path: \"/dashboard\",\n    roles: [], // This route only requires authentication, no specific roles\n    unauthorizedPath: \"/unauthorized\",\n  },\n  // Add more protected routes here as needed\n  // Example:\n  // {\n  //   path: \"/admin\",\n  //   roles: [\"admin\"],\n  //   unauthorizedPath: \"/unauthorized\"\n  // }\n];\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  });\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll();\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value, options }) =>\n            request.cookies.set(name, value)\n          );\n\n          supabaseResponse = NextResponse.next({\n            request,\n          });\n\n          cookiesToSet.forEach(({ name, value, options }) =>\n            supabaseResponse.cookies.set(name, value, options)\n          );\n        },\n      },\n    }\n  );\n\n  for (const route of protectedRoutes) {\n    if (request.nextUrl.pathname.startsWith(route.path)) {\n      const unauthorizedPath = await protectPath(\n        supabase,\n        route.roles,\n        false,\n        route.unauthorizedPath\n      );\n      if (unauthorizedPath) {\n        const redirectUrl = new URL(unauthorizedPath, request.url);\n        const previousPage = request.headers.get(\"referer\") || \"/\";\n        redirectUrl.searchParams.set(\"from\", previousPage);\n        return NextResponse.redirect(redirectUrl);\n      }\n    }\n  }\n\n  return NextResponse.next();\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAEA;AAAA;AAGA;;;;AAEA;;;;;;;;;;;;;CAaC,GACD,eAAe,YACb,QAAwB,EACxB,KAAsB,EACtB,cAAuB,KAAK,EAC5B,mBAA2B,eAAe;IAE1C,IAAI,aAAa;IAEjB,MAAM,kBAAkB,MAAM,IAAA,sJAAS,EAAC;IACxC,IAAI,CAAC,iBAAiB;QACpB,OAAO;IACT;IAEA,IAAI,CAAC,SAAS,MAAM,MAAM,KAAK,GAAG;QAChC,OAAO;IACT;IAEA,IAAI,aAAa;QACf,aAAa,MAAM,IAAA,0JAAa,EAAC,UAAU;IAC7C,OAAO;QACL,aAAa,MAAM,IAAA,sJAAS,EAAC,UAAU;IACzC;IAEA,IAAI,CAAC,YAAY;QACf,OAAO;IACT;IAEA,OAAO;AACT;AAEA,MAAM,kBAAkB;IACtB;QACE,MAAM;QACN,OAAO,EAAE;QACT,kBAAkB;IACpB;CAQD;AAEM,eAAe,cAAc,OAAoB;IACtD,IAAI,mBAAmB,gMAAY,CAAC,IAAI,CAAC;QACvC;IACF;IAEA,MAAM,WAAW,IAAA,uMAAkB,sUAGjC;QACE,SAAS;YACP;gBACE,OAAO,QAAQ,OAAO,CAAC,MAAM;YAC/B;YACA,QAAO,YAAY;gBACjB,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,QAAQ,OAAO,CAAC,GAAG,CAAC,MAAM;gBAG5B,mBAAmB,gMAAY,CAAC,IAAI,CAAC;oBACnC;gBACF;gBAEA,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,iBAAiB,OAAO,CAAC,GAAG,CAAC,MAAM,OAAO;YAE9C;QACF;IACF;IAGF,KAAK,MAAM,SAAS,gBAAiB;QACnC,IAAI,QAAQ,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,IAAI,GAAG;YACnD,MAAM,mBAAmB,MAAM,YAC7B,UACA,MAAM,KAAK,EACX,OACA,MAAM,gBAAgB;YAExB,IAAI,kBAAkB;gBACpB,MAAM,cAAc,IAAI,IAAI,kBAAkB,QAAQ,GAAG;gBACzD,MAAM,eAAe,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc;gBACvD,YAAY,YAAY,CAAC,GAAG,CAAC,QAAQ;gBACrC,OAAO,gMAAY,CAAC,QAAQ,CAAC;YAC/B;QACF;IACF;IAEA,OAAO,gMAAY,CAAC,IAAI;AAC1B"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { type NextRequest } from \"next/server\";\n\nimport { updateSession } from \"@/lib/supabase/server/middleware\";\n\nexport async function middleware(request: NextRequest) {\n  return await updateSession(request);\n}\n\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    \"/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)\",\n  ],\n};\n"],"names":[],"mappings":";;;;;;AAEA;;AAEO,eAAe,WAAW,OAAoB;IACnD,OAAO,MAAM,IAAA,gKAAa,EAAC;AAC7B;AAEO,MAAM,SAAS;IACpB,SAAS;QACP;;;;;KAKC,GACD;KACD;AACH"}}]
}